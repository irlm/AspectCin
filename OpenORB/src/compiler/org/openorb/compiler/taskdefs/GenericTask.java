/*
* Copyright (C) The Community OpenORB Project. All rights reserved.
*
* This software is published under the terms of The OpenORB Community Software
* License version 1.0, a copy of which has been included with this distribution
* in the LICENSE.txt file.
*/

package org.openorb.compiler.taskdefs;

import java.io.File;
import java.io.IOException;

import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;

import org.apache.tools.ant.taskdefs.MatchingTask;

import org.apache.tools.ant.types.Path;

import org.apache.tools.ant.util.SourceFileScanner;

import org.openorb.compiler.CompileListEntry;
import org.openorb.compiler.CompilerHost;
import org.openorb.compiler.CompilerIF;
import org.openorb.compiler.CompilerProperties;

import org.openorb.compiler.parser.CompilationException;

import org.openorb.util.launcher.PropertyManager;
import org.openorb.util.launcher.CompoundClassLoader;

/**
 * This class is the Generic AntTask for the All OpenORB Compilers.
 *
 * @author Erik Putrycz
 * @version $Revision: 1.11 $ $Date: 2005/03/13 13:05:19 $
 */
public abstract class GenericTask
    extends MatchingTask
    implements CompilerActionsListener, CompilerHost
{
    /**
     * Source Path for the src and include and exclude nested tags
     */
    protected Path m_src_path;

    /**
     * contains the last exception found in parameter parsing
     */
    protected BuildException m_param_exception = null;

    /**
     * the cache used for helping uptodate checks
     */
    protected CacheFileNameMapper m_cache = null;

    /**
     * used for storing all the Java files generated by the compiler
     * for the current idl file
     */
    private Vector m_current_java_dests = null;

    protected boolean m_uptodate_check = true;

    protected GenericTask m_currentTask = null;

    protected CompilerProperties m_cp = null;

    protected CompilerIF m_comp = null;

    private static boolean s_urlhandler_initialized;

    protected boolean m_use_bundled_idl = true;
    protected File m_cacheFile = new File( getDefaultCacheName() );

    public void init()
    {
        super.init();
        m_cp = m_comp.createEmptyProperties();

        final ClassLoader contextClassLoader
                = Thread.currentThread().getContextClassLoader();

        final ClassLoader classLoader = CompoundClassLoader.join(
                contextClassLoader, getClass().getClassLoader() );

        Thread.currentThread().setContextClassLoader( classLoader );

        try
        {
            m_comp.init_compiler( this, m_cp );
        }
        catch ( Exception ex )
        {
            log( "Impossible initialize compiler:" + ex );
            ex.printStackTrace();
        }

        finally
        {
            Thread.currentThread().setContextClassLoader( contextClassLoader );
        }
    }

    /**
     * Method called by the compiler each time a new Java file is generated
     * Used for the caching and uptodate checks
     * @param file current java file
     */
    public void addTargetJavaFile( File file )
    {
        if ( m_currentTask.m_current_java_dests != null )
        {
            try
            {
                file = file.getCanonicalFile();
            }
            catch ( IOException e )
            {
                // do nothing
            }
            String filename = file.getPath();

            if ( !m_currentTask.m_current_java_dests.contains( filename ) )
            {
                m_currentTask.m_current_java_dests.add( filename );
            }
        }
    }

    public Path createSrc()
    {
        if ( m_src_path == null )
        {
            m_src_path = new Path( getProject() );
        }

        return m_src_path.createPath();
    }

    private void initURLStreamHandler()
    {
        if ( !s_urlhandler_initialized )
        {
            PropertyManager.JAVA_PROTOCOL_HANDLER_PKGS.postfixValue(
                    "org.openorb.util.urlhandler" );

            s_urlhandler_initialized = true;
        }
    }

    /**
     * Returns the singleton reference for each sub class
     * @return GenericTask
     */
    protected abstract GenericTask getSingleton();

    /**
     * This method allows to override the compilation task
     * psdl2java requires several calls to the compiler.
     *
     * @param cle source file
     * @throws CompilationException
     */
    protected void compile_file( CompileListEntry cle )
        throws CompilationException
    {
        m_comp.compile_file( cle, m_cp );
    }

    /**
     * Run the IDL compiler
     * @see org.apache.tools.ant.Task#execute()
     */
    public void execute() throws BuildException
    {
        m_comp.execute_compiler( this, m_cp );

        m_currentTask = getSingleton();

        log( "using cache file " + m_cacheFile.getAbsolutePath(), Project.MSG_VERBOSE );
        final CacheFileNameMapper cacheFileNameMapper =
              new CacheFileNameMapper( this, m_cacheFile );
        cacheFileNameMapper.setVerbose( m_cp.getM_verbose() );
        m_currentTask.m_cache = cacheFileNameMapper;

        initURLStreamHandler();

        final ClassLoader contextClassLoader
                = Thread.currentThread().getContextClassLoader();

        final ClassLoader classLoader = CompoundClassLoader.join(
                contextClassLoader, getClass().getClassLoader() );

        Thread.currentThread().setContextClassLoader( classLoader );

        m_currentTask.m_cache.init( false );

        try
        {

            // validates the task specific attributes

            validateAttributes();

            // valides the IdlCompiler generic attributes

            validateIdlCompilerAttributes();

            // -- Starts the compilation --
            try
            {
                Iterator it = m_cp.getM_compileList().iterator();

                while ( it.hasNext() )
                {
                    CompileListEntry cle = ( CompileListEntry ) it.next();

                    if ( !m_cp.getM_silentMode() )
                    {
                        log( "compile : " + cle.getFileName() );
                    }

                    // empty the current target files
                    m_currentTask.m_current_java_dests = new Vector();

                    compile_file( cle );

                    m_currentTask.m_cache.addEntry(
                        new File( cle.getSrcPath(), cle.getFileName() ),
                        ( String[] ) ( m_currentTask
                                       .m_current_java_dests
                                       .toArray( new String[ 0 ] ) ) );

                }
            }
            catch ( org.openorb.compiler.parser.CompilationException ex )
            {
                throw new BuildException( "there are errors...", getLocation() );
            }

            // write the dependency cache to disk
            m_currentTask.m_cache.writeCache();
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( contextClassLoader );
        }
    }

    /**
     * Scans the directory looking for source files to be compiled.
     * The results are returned in the class variable compileList
     */
    protected void scanDir( File srcDir, File destDir, String[] files )
    {
        //inform the Cache about the source directory
        m_currentTask.m_cache.setCurrentSrcDir( srcDir );
        SourceFileScanner sfs = new SourceFileScanner( this );
        String[] newFiles = null;

        if ( m_uptodate_check )
        {
            newFiles =
                sfs.restrict(
                    files,
                    srcDir,
                    null,
                    m_currentTask.m_cache );
        }
        else
        {
            // just copy the source array
            newFiles = new String[ files.length ];

            for ( int il = 0; il < files.length; il++ )
            {
                newFiles[ il ] = files[ il ];
            }
        }

        if ( newFiles.length > 0 )
        {
            for ( int il = 0; il < newFiles.length; il++ )
            {
                CompileListEntry cle = new CompileListEntry( srcDir, newFiles[il] );
                m_cp.getM_compileList().add( cle );
            }

        }

    }

    /**
     * validate the task specific attributes
     * @throws BuildException
     */
    protected abstract void validateAttributes() throws BuildException;


    /**
     * Valides the idl compiler attributes (used in all sub compilers)
     * @throws BuildException
     */
    protected void validateIdlCompilerAttributes() throws BuildException
    {

        if ( m_param_exception != null )
        {
            throw m_param_exception;
        }

        // load the IDL file list from the include and path structures
        if ( m_src_path == null )
        {
            throw new BuildException( "srcdir attribute must be set!", getLocation() );
        }

        if ( m_src_path.size() == 0 )
        {
            throw new BuildException( "srcdir attribute must be set!", getLocation() );
        }

        String[] list = m_src_path.list();

        for ( int jl = 0; jl < list.length; jl++ )
        {
            File srcDir = getProject().resolveFile( list[ jl ] );

            if ( !srcDir.exists() )
            {
                throw new BuildException(
                    "srcdir \"" + srcDir.getPath() + "\" doesn't exist!",
                    getLocation() );
            }

            if ( srcDir.isDirectory() )
            {
                DirectoryScanner ds = super.getDirectoryScanner( srcDir );

                String[] srcFiles = ds.getIncludedFiles();

                scanDir( srcDir, m_cp.getM_destdir(), srcFiles );
            }

        }

        if ( m_cp.getM_destdir() == null || m_cp.getM_destdir().equals( "" ) )
        {
            m_cp.setM_destdir( new File( "generated" ) );

            if ( m_cp.getM_packageName() == null )
            {
                m_cp.setM_packageName( "" );
                m_cp.setM_use_package( false );
            }
        }

        m_cp.setM_clistener( this );

    }

    /**
     * Set the include path ("-I" param)
     * @param path
     */
    public void setIncludePath( String path )
    {
        StringTokenizer st = new StringTokenizer( path, ";, " );

        while ( st.hasMoreTokens() )
        {
            m_cp.getM_includeList().addElement( st.nextToken() );
        }

    }

    /**
     * @see org.openorb.compiler.CompilerHost#display(java.lang.String)
     */
    public void display( String s )
    {
        log( s );
    }

    /**
     * The default name of the cache file to use.
     * @return the default name of the cache file to use.
     */
    protected abstract String getDefaultCacheName();

    /**
     * Lets user control cache file location.
     * @param cacheFile the cachefile to use
     */
    public void setCacheFile( File cacheFile )
    {
        m_cacheFile = cacheFile;
    }

}
